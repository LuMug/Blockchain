\documentclass[../documentation.tex]{subfiles}

\begin{document}

\subsection{Peer Discovery}

\subsubsection{Seeder}

The first step of our peer discovery solution is the \textit{Seeder}.
The Seeder is a server which stores information about node's service addresses.
\\
A node might register himself to a seeder by opening a TCP connection and sending
a \texttt{RegisterNode} packet.
Likewise, a node might ask a seeder the service addresses of \textbf{N} nodes by sending a
\texttt{RequestNodes} packet.

When the seeder receives a \texttt{RegisterNode} it will store its address in the
services pool. The services pool has a fixed capacity of \texttt{POOL\_CAPACITY}.
Nodes are stored along with their registration timestamp, this means that when the pool
reaches max capacity the oldest node will be uncached. If an already registered node
send a registration packet, the timestamp is updated.
Connection is then closed.

When the seeder receives a \texttt{RequestNodes} it will try to randomly draw
as many nodes as requested (max \texttt{MAX\_REQUEST}) excluding the requester itself.
The \texttt{ServeRequestNodes} response packet will be sent back.
Connection is then closed.

\subsubsection{Cache}

The nodes will also locally cache some of the peers.
To do so we define the \textit{node} table.

\begin{lstlisting}[style=sql]
    CREATE TABLE IF NOT EXISTS node (
        address VARCHAR(20),
        port INT,
        last_seen_alive DATETIME,
        PRIMARY KEY (address, port)
    );
\end{lstlisting}

When a connection to a peer is established, the node is added to this table.
If the node is already in the database, its \textit{last\_seen\_alive} field is updated.
\\
If the number of nodes in the cache exceeds \texttt{MAX\_CACHED\_NODES},
the node with the oldest \textit{last\_seen\_alive} field is deleted.

\subsubsection{Algorithm}

A node will actively try to always have \texttt{MIN\_CONNECTIONS} established connections.
If the number of connections exceeds \texttt{MAX\_CONNECTIONS}, a random peer is disconnected.

The node will periodically register himself to a random seeder every \texttt{REGISTER\_INTERVAL} ms.
By doing this dead nodes will stop registering and exit the seeder pool.

The node will periodically execute the following update every \texttt{UPDATE\_INTERVAL} ms:

\begin{enumerate}
    \item If peers are less than \texttt{MIN\_CONNECTIONS}, update from a random peer up to \texttt{MAX\_TRIES\_NEIGHBOUR} times
    \item If peers are less than \texttt{MIN\_CONNECTIONS}, update from local cache
    \item If peers are \(0\), update from a random seeder up to \texttt{MAX\_TRIES\_SEEDER} times
\end{enumerate}

\pagebreak

\paragraphln{Picking a random seeder}
Seeder addresses are hard-coded in the \texttt{SEEDERS} array.
Start with a random index, if that seeder is unreachable traverse the array in a circular manner
until one is reachable.

% Circular iterator

\begin{center}
    \begin{tikzcd}
        &&& {\text{rnd}} \\
        {\text{el}_0} & {\text{el}_1} & {\text{el}_2} & {\text{el}_3} & {\text{el}_4}
        \arrow[from=1-4, to=2-4]
        \arrow[from=2-1, to=2-2, bend left=60]
        \arrow[from=2-2, to=2-3, bend left=60]
        \arrow[from=2-4, to=2-5, bend left=60]
        \arrow[from=2-5, to=2-1, bend left=60]
    \end{tikzcd}
\end{center}

\paragraphln{Updating from local cache}
\paragraphln{Updating from seeder}
\paragraphln{Update from a peer}
% last_time_seen + cache
% + registration

\pagebreak

\subsection{Constants}

Here is a list of hard-coded values.

\paragraphln{Database}
Constants related to the database node caching

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CACHED\_NODES & 50
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Blockchain}
Constants related to the blockchain system:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    BLOCK\_REWARD & 1000
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Node}
Constants related to the peer connections:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CONNECTIONS & 150
    \\ \hline
    MIN\_CONNECTIONS & 100
    \\ \hline
    REGISTER\_INTERVAL & 180000
    \\ \hline
    UPDATE\_INTERVAL & 180000
    \\ \hline
    MAX\_TRIES\_SEEDER & 5
    \\ \hline
    MAX\_TRIES\_NEIGHBOUR & 5
    \\ \hline
    SEEDERS & \makecell[t] {
        127.0.0.1:4670 \\
        127.0.0.1:4671 \\
        127.0.0.1:4672
    }
    \\ \hline
\end{tabular}
\egroup{}

\subsection{Packets}

% some command to link packets (texttt + hyperref to section)
% and constants

\end{document}
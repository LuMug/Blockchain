\documentclass[../documentation.tex]{subfiles}

\begin{document}

\newcommand{\const}[1]{\hyperlink{constants}{\texttt{#1}}}
\newcommand{\packet}[1]{\hyperlink{packets}{\texttt{#1}}}

\subsection{Peer Discovery}

\subsubsection{Registration}

When a node starts it generates a random UUID.

When to peers establish a connection, they change a
\packet{RegisterNode} packet. This packet contains information
about their service address and UUID.

\subsubsection{Seeder}

The first step of our peer discovery solution is the \textit{Seeder}.
The Seeder is a server which stores information about node's service addresses.
\\
A node might register himself to a seeder by opening a TCP connection and sending
a \packet{RegisterNode} packet.
Likewise, a node might ask a seeder the service addresses of \textbf{N} nodes by sending a
\packet{RequestNodes} packet.

When the seeder receives a \packet{RegisterNode} it will store its address in the
services pool. The services pool has a fixed capacity of \const{POOL\_CAPACITY}.
Nodes are stored along with their registration timestamp, this means that when the pool
reaches max capacity the oldest node will be uncached. If an already registered node
send a registration packet, the timestamp is updated.
Connection is then closed.

When the seeder receives a \packet{RequestNodes} it will try to randomly draw
as many nodes as requested (max \const{MAX\_REQUEST}) excluding the requester itself.
The \packet{ServeRequestNodes} response packet will be sent back.
Connection is then closed.

It is important to only rely on a seeder when 0 peers are known or when all
the known peers are unreachable.

If a node with an already registered address does register with a new UUID, the old entry is removed.

\subsubsection{Cache}

The nodes will also locally cache some of the peers.
To do so we define the \textit{node} table.

\begin{lstlisting}[style=sql]
    CREATE TABLE IF NOT EXISTS node (
        address VARCHAR(20),
        port INT,
        last_seen_alive DATETIME,
        PRIMARY KEY (address, port)
    );
\end{lstlisting}

When a connection to a peer is established, the node is added to this table.
If the node is already in the database, its \textit{last\_seen\_alive} field is updated.
\\
If the number of nodes in the cache exceeds \const{MAX\_CACHED\_NODES},
the node with the oldest \textit{last\_seen\_alive} field is deleted.

\subsubsection{Algorithm}

A node will actively try to always have \const{MIN\_CONNECTIONS} established connections.
If the number of connections exceeds \const{MAX\_CONNECTIONS}, a random peer is disconnected.

The node will periodically register himself to a random seeder every \const{REGISTER\_INTERVAL} ms.
By doing this dead nodes will stop registering and exit the seeder pool.

\pagebreak

The node will periodically execute the following update every \const{UPDATE\_INTERVAL} ms:

\begin{enumerate}
    \item If peers are less than \const{MIN\_CONNECTIONS}, update from a random peer up to \texttt{MAX\_TRIES\_NEIGHBOUR} times
    \item If peers are less than \const{MIN\_CONNECTIONS}, update from local cache
    \item If peers are \(0\), update from a random seeder up to \const{MAX\_TRIES\_SEEDER} times
\end{enumerate}

\paragraphln{Picking a random seeder}
Seeder addresses are hard-coded in the \const{SEEDERS} array.
Start with a random index, if that seeder is unreachable traverse the array in a circular manner
until one is reachable.

% Circular iterator
\begin{center}
    \begin{tikzcd}
        &&& {\text{rnd}} \\
        {\text{el}_0} & {\text{el}_1} & {\text{el}_2} & {\text{el}_3} & {\text{el}_4}
        \arrow[from=1-4, to=2-4]
        \arrow[from=2-1, to=2-2, bend left=60]
        \arrow[from=2-2, to=2-3, bend left=60]
        \arrow[from=2-4, to=2-5, bend left=60]
        \arrow[from=2-5, to=2-1, bend left=60]
    \end{tikzcd}
\end{center}

\paragraphln{Updating from local cache}
\begin{enumerate}
    \item Read all cached peers from the database
    \item Filter the ones without an estblished connection
    \item While there is still room, try to establish a connection with them
\end{enumerate}

\paragraphln{Updating from seeder}
\begin{enumerate}
    \item Establish a TCP connection with the seeder
    \item Send a \packet{RequestNodes} packet requesting
        \((\text{\const{MIN\_CONNECTIONS}} - \text{\texttt{CONNECTIONS}})\) peers
    \item Filter the ones without an estblished connection
    \item Try to connect to each of them
\end{enumerate}

\paragraphln{Update from a peer}
\begin{enumerate}
    \item Send a \packet{RequestNodes} packet requesting
        \((\text{\const{MIN\_CONNECTIONS}} - \text{\texttt{CONNECTIONS}})\) peers
    \item Filter the ones without an estblished connection
    \item Try to connect to each of them
\end{enumerate}

When a node receives a \packet{RequestNodes}
it will try to randomly draw as many nodes as requested (max
\const{MAX\_REQUEST}) excluding the requester itself.
The \packet{ServeRequestNodes} response packet will be sent back.

\pagebreak

\subsection{Wallet}

\subsubsection{Keypair}

A wallet can be create by generating an \textbf{EdDSA}
(Elliptic Curve Digital Signature Algorithm) keypair
on the \textit{ed25519} curve.

The public key can be retrieved given the private key.

\subsubsection{Address}

The public wallet address is given by the hash of the public key.

\[
    \text{address}=\text{SHA}_{256}(\text{key}_\text{priv})
\]

and the human-readable version

\[
    \text{address}_\text{UTF-8}=\text{base64}(\text{SHA}_{256}(\text{key}_\text{priv}))
\]

\subsection{Mining}

A miner will try to compute the following:

\[
    \theta =
    \text{SHA}_{256}(\text{height})
    \oplus
    \text{SHA}_{256}(\text{nonce})
    \oplus
    \underset{i}{\oplus}\,
    \text{SHA}_{256}(\text{tx}_i)
\]

Where \(\oplus\) denotes the XOR operator and 
\(\underset{i}{\oplus}\) denotes the XOR over a set,
so \(0 \leq i < \text{length}(\text{tx})\).

A block is mined if a value for \textit{nonce} such that

\[
    \Theta \text{TODO}
\]

is found.

\subsection{Nodes}

\begin{center}
    \begin{tikzpicture}[font=\ttfamily,
        mymatrix/.style={matrix of nodes, nodes=typetag, row sep=1em},
        mycontainer/.style={draw=gray, inner sep=1ex},
        typetag/.style={draw=gray, inner sep=1ex, anchor=west},
        title/.style={draw=none, color=gray, inner sep=0pt}
        ]
        \matrix[mymatrix] (mx1) {
            |[title]|API Node \phantom{g} \\ % \phantom{g} to add an invisible g
                                             % otherwise m2 is taller
            Full Node \\
        };
        \matrix[mymatrix, right=of mx1.north east, matrix anchor=north west] (mx2) {
            |[title]|Mining Node \\
            Full Node \\
        };
        \matrix[mymatrix, right=of mx2.north east, matrix anchor=north west] (mx3) {
            |[title]|Full Node \\
        };
    
        \node[mycontainer, fit=(mx1)] {};
        \node[mycontainer, fit=(mx2)] {};
        \node[mycontainer, fit=(mx3)] {};
    \end{tikzpicture}
\end{center}

\bgroup{}
\def\arraystretch{1.25}
\begin{center}
    \begin{tabular}{ |c|c|c|c| }
        \hline
        &
        \textbf{\makecell[c]{Makes new \\ blocks}} &
        \textbf{\makecell[c]{Deploys \\ transactions}} &
        \textbf{\makecell[c]{knows all \\ transactions}} \\
        \hline
        \makecell[l]{Full Node} & - & - & + \\
        \hline
        \makecell[l]{API Node} & - & + & + \\
        \hline
        \makecell[l]{Mining Node} & + & - & + \\
        \hline
    \end{tabular}
\end{center}
\egroup{}


\pagebreak

\hypertarget{constants}{}
\subsection{Constants}

Here is a list of hard-coded values.

\paragraphln{Database}
Constants related to the database node caching

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CACHED\_NODES & 50
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Blockchain}
Constants related to the blockchain system:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    BLOCK\_REWARD & 1000
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Node}
Constants related to the peer connections:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CONNECTIONS & 150
    \\ \hline
    MIN\_CONNECTIONS & 100
    \\ \hline
    REGISTER\_INTERVAL & 180000
    \\ \hline
    UPDATE\_INTERVAL & 180000
    \\ \hline
    MAX\_TRIES\_SEEDER & 5
    \\ \hline
    MAX\_TRIES\_NEIGHBOUR & 5
    \\ \hline
    SEEDERS & \makecell[t] {
        127.0.0.1:4670 \\
        127.0.0.1:4671 \\
        127.0.0.1:4672
    }
    \\ \hline
\end{tabular}
\egroup{}

\pagebreak

\hypertarget{packets}{}
\subsection{Packets}

Packets are sent over a TCP socket stream.
Each packet is preceded by the length of the packet,
encoded as a Little-Endian 32-bit integer.


\newcommand{\tline}{
    \\ \hline
}

\newcommand{\packettabular}[1]{
    \bgroup{}
    \def\arraystretch{1.25}
    \begin{center}
        \begin{tabular}{|l|l|l|}
            \hline
            \textbf{Name} & \textbf{Type} & \textbf{Descritpion}
            \tline
            ID & u8 & Packet Identifier
            \tline
            #1
            \tline
        \end{tabular}
    \end{center}
    \egroup{}
}

\subsubsection{PoWSolvedPacket}

Used when a miner mines a block.

\packettabular{
    nonce & blob & The mined nonce
    \tline
    miner & blob & Address of the miner
    \tline
    timestamp & u64 & Timestamp
}

\subsubsection{RegisterNodePacket}

Used to register the node service to another peer or a seedeer.

\packettabular{
    port & u16 & The port of the service
    \tline
    uuid & UUID & The UUID of the node
}

\subsubsection{RequestBlockchainLengthPacket}

\packettabular{

}

\subsubsection{RequestIfHashExistsPacket}

\packettabular{

}

\subsubsection{RequestNodesPacket}

\packettabular{
    amount & u32 & Requested amount
    \tline
    exclude & UUID & UUID to exclude
}

\subsubsection{SendTransactionPacket}

\packettabular{
    timestamp & u64 & The timestamp
    \tline
    recipient & blob & Recipient address
    \tline
    sender\_pub & blob & Sender public key
    \tline
    amount & u64 & The amount of the transaction
    \tline
    last\_tx\_hash & blob & The hash of the last transaction
    \tline
    signature & blob & The signature
}

\subsubsection{ServeBlockchainLengthPacket}

\packettabular{

}

\subsubsection{ServeIfHashExistsPacket}

\packettabular{

}

\subsubsection{ServeNodesPacket}

\packettabular{

}

\end{document}
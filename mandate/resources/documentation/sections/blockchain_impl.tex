\documentclass[../documentation.tex]{subfiles}

\begin{document}

\newcommand{\const}[1]{\hyperlink{constants}{\texttt{#1}}}
\newcommand{\packet}[1]{\hyperlink{packets}{\texttt{#1}}}

\subsection{Peer Discovery}

\subsubsection{Registration}

When a node starts it generates a random UUID.

When to peers establish a connection, they change a
\packet{RegisterNode} packet. This packet contains information
about their service address and UUID.

\subsubsection{Seeder}

The first step of our peer discovery solution is the \textit{Seeder}.
The Seeder is a server which stores information about node's service addresses.
\\
A node might register himself to a seeder by opening a TCP connection and sending
a \packet{RegisterNode} packet.
Likewise, a node might ask a seeder the service addresses of \textbf{N} nodes by sending a
\packet{RequestNodes} packet.

When the seeder receives a \packet{RegisterNode} it will store its address in the
services pool. The services pool has a fixed capacity of \const{POOL\_CAPACITY}.
Nodes are stored along with their registration timestamp, this means that when the pool
reaches max capacity the oldest node will be uncached. If an already registered node
send a registration packet, the timestamp is updated.
Connection is then closed.

When the seeder receives a \packet{RequestNodes} it will try to randomly draw
as many nodes as requested (max \const{MAX\_REQUEST}) excluding the requester itself.
The \packet{ServeRequestNodes} response packet will be sent back.
Connection is then closed.

It is important to only rely on a seeder when 0 peers are known or when all
the known peers are unreachable.

If a node with an already registered address does register with a new UUID, the old entry is removed.

\subsubsection{Cache}

The nodes will also locally cache some of the peers.
To do so we define the \textit{node} table.

\begin{lstlisting}[style=sql]
    CREATE TABLE IF NOT EXISTS node (
        address VARCHAR(20),
        port INT,
        last_seen_alive DATETIME,
        PRIMARY KEY (address, port)
    );
\end{lstlisting}

When a connection to a peer is established, the node is added to this table.
If the node is already in the database, its \textit{last\_seen\_alive} field is updated.
\\
If the number of nodes in the cache exceeds \const{MAX\_CACHED\_NODES},
the node with the oldest \textit{last\_seen\_alive} field is deleted.

\subsubsection{Algorithm}

A node will actively try to always have \const{MIN\_CONNECTIONS} established connections.
If the number of connections exceeds \const{MAX\_CONNECTIONS}, a random peer is disconnected.

The node will periodically register himself to a random seeder every \const{REGISTER\_INTERVAL} ms.
By doing this dead nodes will stop registering and exit the seeder pool.

\pagebreak

The node will periodically execute the following update every \const{UPDATE\_INTERVAL} ms:

\begin{enumerate}
    \item If peers are less than \const{MIN\_CONNECTIONS}, update from a random peer up to \texttt{MAX\_TRIES\_NEIGHBOUR} times
    \item If peers are less than \const{MIN\_CONNECTIONS}, update from local cache
    \item If peers are \(0\), update from a random seeder up to \const{MAX\_TRIES\_SEEDER} times
\end{enumerate}

\paragraphln{Picking a random seeder}
Seeder addresses are hard-coded in the \const{SEEDERS} array.
Start with a random index, if that seeder is unreachable traverse the array in a circular manner
until one is reachable.

% Circular iterator

\begin{center}
    \begin{tikzcd}
        &&& {\text{rnd}} \\
        {\text{el}_0} & {\text{el}_1} & {\text{el}_2} & {\text{el}_3} & {\text{el}_4}
        \arrow[from=1-4, to=2-4]
        \arrow[from=2-1, to=2-2, bend left=60]
        \arrow[from=2-2, to=2-3, bend left=60]
        \arrow[from=2-4, to=2-5, bend left=60]
        \arrow[from=2-5, to=2-1, bend left=60]
    \end{tikzcd}
\end{center}

\paragraphln{Updating from local cache}
\begin{enumerate}
    \item Read all cached peers from the database
    \item Filter the ones without an estblished connection
    \item While there is still room, try to establish a connection with them
\end{enumerate}

\paragraphln{Updating from seeder}
\begin{enumerate}
    \item Establish a TCP connection with the seeder
    \item Send a \packet{RequestNodes} packet requesting
        \((\text{\const{MIN\_CONNECTIONS}} - \text{\texttt{CONNECTIONS}})\) peers
    \item Filter the ones without an estblished connection
    \item Try to connect to each of them
\end{enumerate}

\paragraphln{Update from a peer}
\begin{enumerate}
    \item Send a \packet{RequestNodes} packet requesting
        \((\text{\const{MIN\_CONNECTIONS}} - \text{\texttt{CONNECTIONS}})\) peers
    \item Filter the ones without an estblished connection
    \item Try to connect to each of them
\end{enumerate}

When a node receives a \packet{RequestNodes}
it will try to randomly draw as many nodes as requested (max
\const{MAX\_REQUEST}) excluding the requester itself.
The \packet{ServeRequestNodes} response packet will be sent back.

\pagebreak

\hypertarget{constants}{}
\subsection{Constants}

Here is a list of hard-coded values.

\paragraphln{Database}
Constants related to the database node caching

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CACHED\_NODES & 50
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Blockchain}
Constants related to the blockchain system:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    BLOCK\_REWARD & 1000
    \\ \hline
\end{tabular}
\egroup{}

\paragraphln{Node}
Constants related to the peer connections:

\bgroup{}
\def\arraystretch{1.25}
\begin{tabular}{|l|l|}
    \hline
    \textbf{Name} & \textbf{Value}
    \\ \hline
    MAX\_CONNECTIONS & 150
    \\ \hline
    MIN\_CONNECTIONS & 100
    \\ \hline
    REGISTER\_INTERVAL & 180000
    \\ \hline
    UPDATE\_INTERVAL & 180000
    \\ \hline
    MAX\_TRIES\_SEEDER & 5
    \\ \hline
    MAX\_TRIES\_NEIGHBOUR & 5
    \\ \hline
    SEEDERS & \makecell[t] {
        127.0.0.1:4670 \\
        127.0.0.1:4671 \\
        127.0.0.1:4672
    }
    \\ \hline
\end{tabular}
\egroup{}

\hypertarget{packets}{}
\subsection{Packets}

Packets are sent over a TCP socket stream.
Each packet is preceded by the length of the packet,
encoded as a Little-Endian 32-bit integer.

\subsubsection{PoWSolvedPacket}

% TODO

\subsubsection{RegisterNodePacket}

% TODO

\subsubsection{RequestBlockchainLengthPacket}

% TODO

\subsubsection{RequestIfHashExistsPacket}

% TODO

\subsubsection{RequestNodesPacket}

% TODO

\subsubsection{SendTransactionPacket}

% TODO

\subsubsection{ServeBlockchainLengthPacket}

% TODO

\subsubsection{ServeIfHashExistsPacket}

% TODO

\subsubsection{ServeNodesPacket}

% TODO


\subsection{Nodes}

dik

\end{document}
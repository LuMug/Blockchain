fn main() {
    let a = 2 i32;
    fun(&a);
}

fn fun(ptr *i32): i32 {
    let a = 2; i32
    let b = *ptr;
    *ptr = 5 i32;
    ret b;
}

------------------------

% -> comment
; -> bytecode position
: -> stack position
<function>-start -> function initial stack position
<function>_<name> -> local variable

GOTO_A -> GOTO NEXT()
GOTO_B -> if POP() GOTO NEXT()
GOTO_C -> GOTO POP()

WRITE -> write POP() value at :ptr

DEALLOC_A dealloc [:ptr to END]
DEALLOC_B dealloc [:ptr to :<function>-ret[ and then collapse :<function>-ret on top of the stack

--------------------------

GOTO_A      ;main

PUSH        2 i32           ;fun, :fun_a
READ        :fun_ptr        :fun_b
PUSH        5 i32
WRITE       :fun_ptr
PUSH        :fun_b          :fun-ret
DEALLOC_B   :fun_start,
            :fun-ret
SWAP
GOTO_C

PUSH        2 i32           ;main, :main_a, :main-start
PUSH        %POS%
PUSH        :main_a         :fun_ptr, :fun-start
GOTO_A      ;fun
POP                         % remove unused return
DEALLOC_A   :main_start